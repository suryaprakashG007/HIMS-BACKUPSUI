"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMenuOffset = exports.default = exports.OverflowMenu = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _invariant = _interopRequireDefault(require("invariant"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _ClickListener = _interopRequireDefault(require("../../internal/ClickListener"));

var _FloatingMenu = _interopRequireWildcard(require("../../internal/FloatingMenu"));

var _iconsReact = require("@carbon/icons-react");

var _keyboard = require("../../internal/keyboard");

var _mergeRefs = _interopRequireDefault(require("../../tools/mergeRefs"));

var _usePrefix = require("../../internal/usePrefix");

var FeatureFlags = _interopRequireWildcard(require("@carbon/feature-flags"));

var _deprecate = _interopRequireDefault(require("../../prop-types/deprecate"));

var _setupGetInstanceId = _interopRequireDefault(require("../../tools/setupGetInstanceId"));

var _excluded = ["id", "ariaLabel", "children", "iconDescription", "direction", "flipped", "focusTrap", "menuOffset", "menuOffsetFlip", "iconClass", "onClick", "onOpen", "selectorPrimaryFocus", "renderIcon", "innerRef", "menuOptionsClass", "light", "size"];

var _triggerButtonPositio, _triggerButtonPositio2;

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var getInstanceId = (0, _setupGetInstanceId.default)();

var on = function on(element) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  element.addEventListener.apply(element, args);
  return {
    release: function release() {
      element.removeEventListener.apply(element, args);
      return null;
    }
  };
};
/**
 * The CSS property names of the arrow keyed by the floating menu direction.
 * @type {object<string, string>}
 */


var triggerButtonPositionProps = (_triggerButtonPositio = {}, (0, _defineProperty2.default)(_triggerButtonPositio, _FloatingMenu.DIRECTION_TOP, 'bottom'), (0, _defineProperty2.default)(_triggerButtonPositio, _FloatingMenu.DIRECTION_BOTTOM, 'top'), _triggerButtonPositio);
/**
 * Determines how the position of arrow should affect the floating menu position.
 * @type {object<string, number>}
 */

var triggerButtonPositionFactors = (_triggerButtonPositio2 = {}, (0, _defineProperty2.default)(_triggerButtonPositio2, _FloatingMenu.DIRECTION_TOP, -2), (0, _defineProperty2.default)(_triggerButtonPositio2, _FloatingMenu.DIRECTION_BOTTOM, -1), _triggerButtonPositio2);
/**
 * @param {Element} menuBody The menu body with the menu arrow.
 * @param {string} direction The floating menu direction.
 * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
 * @private
 */

var getMenuOffset = function getMenuOffset(menuBody, direction, trigger, flip) {
  var triggerButtonPositionProp = triggerButtonPositionProps[direction];
  var triggerButtonPositionFactor = triggerButtonPositionFactors[direction];

  if (process.env.NODE_ENV !== "production") {
    !(triggerButtonPositionProp && triggerButtonPositionFactor) ? process.env.NODE_ENV !== "production" ? (0, _invariant.default)(false, '[OverflowMenu] wrong floating menu direction: `%s`', direction) : (0, _invariant.default)(false) : void 0;
  }

  var menuWidth = menuBody.offsetWidth,
      menuHeight = menuBody.offsetHeight;

  switch (triggerButtonPositionProp) {
    case 'top':
    case 'bottom':
      {
        // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
        var triggerWidth = !trigger ? 0 : trigger.offsetWidth;
        return {
          left: (!flip ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
          top: 0
        };
      }

    case 'left':
    case 'right':
      {
        // TODO: Ensure `trigger` is there for `<OverflowMenu open>`
        var triggerHeight = !trigger ? 0 : trigger.offsetHeight;
        return {
          left: 0,
          top: (!flip ? 1 : -1) * (menuHeight / 2 - triggerHeight / 2)
        };
      }

    default:
      break;
  }
};

exports.getMenuOffset = getMenuOffset;

var OverflowMenu = /*#__PURE__*/function (_Component) {
  (0, _inherits2.default)(OverflowMenu, _Component);

  var _super = _createSuper(OverflowMenu);

  function OverflowMenu() {
    var _this;

    (0, _classCallCheck2.default)(this, OverflowMenu);

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "instanceId", getInstanceId());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_hFocusIn", null);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_hBlurTimeout", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_triggerRef", /*#__PURE__*/_react.default.createRef());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleClick", function (evt) {
      evt.stopPropagation();

      if (!_this._menuBody || !_this._menuBody.contains(evt.target)) {
        _this.setState({
          open: !_this.state.open
        });

        _this.props.onClick(evt);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleKeyDown", function (evt) {
      if ((0, _keyboard.matches)(evt, [_keyboard.keys.ArrowDown])) {
        _this.setState({
          open: !_this.state.open
        });

        _this.props.onClick(evt);
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleKeyPress", function (evt) {
      if (_this.state.open && (0, _keyboard.matches)(evt, [_keyboard.keys.ArrowUp, _keyboard.keys.ArrowRight, _keyboard.keys.ArrowDown, _keyboard.keys.ArrowLeft])) {
        evt.preventDefault();
      } // Close the overflow menu on escape


      if ((0, _keyboard.matches)(evt, [_keyboard.keys.Escape])) {
        var wasOpen = _this.state.open;

        _this.closeMenu(function () {
          if (wasOpen) {
            _this.focusMenuEl();
          }
        }); // Stop the esc keypress from bubbling out and closing something it shouldn't


        evt.stopPropagation();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleClickOutside", function (evt) {
      if (_this.state.open && (!_this._menuBody || !_this._menuBody.contains(evt.target))) {
        _this.closeMenu();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "closeMenu", function (onCloseMenu) {
      _this.setState({
        open: false
      }, function () {
        // Optional callback to be executed after the state as been set to close
        if (onCloseMenu) {
          onCloseMenu();
        }

        _this.props.onClose();
      });
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "focusMenuEl", function () {
      var triggerEl = _this._triggerRef.current;

      if (triggerEl) {
        triggerEl.focus();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleOverflowMenuItemFocus", function (_ref) {
      var _overflowMenuItem$cur;

      var currentIndex = _ref.currentIndex,
          direction = _ref.direction;

      var enabledIndices = _react.default.Children.toArray(_this.props.children).reduce(function (acc, curr, i) {
        if (!curr.props.disabled) {
          acc.push(i);
        }

        return acc;
      }, []);

      var nextValidIndex = function () {
        var nextIndex = enabledIndices.indexOf(currentIndex) + direction;

        switch (enabledIndices.indexOf(currentIndex) + direction) {
          case -1:
            return enabledIndices.length - 1;

          case enabledIndices.length:
            return 0;

          default:
            return nextIndex;
        }
      }();

      var overflowMenuItem = _this["overflowMenuItem".concat(enabledIndices[nextValidIndex])].overflowMenuItem;

      overflowMenuItem === null || overflowMenuItem === void 0 ? void 0 : (_overflowMenuItem$cur = overflowMenuItem.current) === null || _overflowMenuItem$cur === void 0 ? void 0 : _overflowMenuItem$cur.focus();
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_bindMenuBody", function (menuBody) {
      if (!menuBody) {
        _this._menuBody = menuBody;
      }

      if (!menuBody && _this._hFocusIn) {
        _this._hFocusIn = _this._hFocusIn.release();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_handlePlace", function (menuBody) {
      if (menuBody) {
        _this._menuBody = menuBody;
        var hasFocusin = ('onfocusin' in window);
        var focusinEventName = hasFocusin ? 'focusin' : 'focus';
        _this._hFocusIn = on(menuBody.ownerDocument, focusinEventName, function (event) {
          var target = _ClickListener.default.getEventTarget(event);

          var triggerEl = _this._triggerRef.current;

          if (typeof target.matches === 'function') {
            if (!menuBody.contains(target) && triggerEl && !target.matches(".".concat(_this.context, "--overflow-menu,.").concat(_this.context, "--overflow-menu-options"))) {
              _this.closeMenu();
            }
          }
        }, !hasFocusin);

        _this.props.onOpen();
      }
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_getTarget", function () {
      var triggerEl = _this._triggerRef.current;
      return triggerEl && triggerEl.closest('[data-floating-menu-container]') || document.body;
    });
    return _this;
  }

  (0, _createClass2.default)(OverflowMenu, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(_, prevState) {
      var onClose = this.props.onClose;

      if (!this.state.open && prevState.open) {
        onClose();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (typeof this._hBlurTimeout === 'number') {
        clearTimeout(this._hBlurTimeout);
        this._hBlurTimeout = undefined;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames,
          _classNames2,
          _this2 = this;

      var prefix = this.context;
      var _this$props = this.props,
          id = _this$props.id,
          ariaLabel = _this$props.ariaLabel,
          children = _this$props.children,
          iconDescription = _this$props.iconDescription,
          direction = _this$props.direction,
          flipped = _this$props.flipped,
          focusTrap = _this$props.focusTrap,
          menuOffset = _this$props.menuOffset,
          menuOffsetFlip = _this$props.menuOffsetFlip,
          iconClass = _this$props.iconClass,
          onClick = _this$props.onClick,
          onOpen = _this$props.onOpen,
          _this$props$selectorP = _this$props.selectorPrimaryFocus,
          selectorPrimaryFocus = _this$props$selectorP === void 0 ? '[data-floating-menu-primary-focus]' : _this$props$selectorP,
          IconElement = _this$props.renderIcon,
          ref = _this$props.innerRef,
          menuOptionsClass = _this$props.menuOptionsClass,
          light = _this$props.light,
          _this$props$size = _this$props.size,
          size = _this$props$size === void 0 ? 'md' : _this$props$size,
          other = (0, _objectWithoutProperties2.default)(_this$props, _excluded);
      var open = this.state.open;
      var overflowMenuClasses = (0, _classnames.default)(this.props.className, "".concat(prefix, "--overflow-menu"), (_classNames = {}, (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--overflow-menu--open"), open), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--overflow-menu--light"), light), (0, _defineProperty2.default)(_classNames, "".concat(prefix, "--overflow-menu--").concat(size), size), _classNames));
      var overflowMenuOptionsClasses = (0, _classnames.default)(menuOptionsClass, "".concat(prefix, "--overflow-menu-options"), (_classNames2 = {}, (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--overflow-menu--flip"), this.props.flipped), (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--overflow-menu-options--open"), open), (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--overflow-menu-options--light"), light), (0, _defineProperty2.default)(_classNames2, "".concat(prefix, "--overflow-menu-options--").concat(size), size), _classNames2));
      var overflowMenuIconClasses = (0, _classnames.default)("".concat(prefix, "--overflow-menu__icon"), iconClass);

      var childrenWithProps = _react.default.Children.toArray(children).map(function (child, index) {
        var _child$props;

        return /*#__PURE__*/_react.default.cloneElement(child, {
          closeMenu: (child === null || child === void 0 ? void 0 : (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.closeMenu) || _this2.closeMenu,
          handleOverflowMenuItemFocus: _this2.handleOverflowMenuItemFocus,
          ref: function ref(e) {
            _this2["overflowMenuItem".concat(index)] = e;
          },
          index: index
        });
      });

      var menuBodyId = "overflow-menu-".concat(this.instanceId, "__menu-body");

      var menuBody = /*#__PURE__*/_react.default.createElement("ul", {
        className: overflowMenuOptionsClasses,
        tabIndex: "-1",
        role: "menu",
        "aria-label": ariaLabel,
        id: menuBodyId
      }, childrenWithProps);

      var wrappedMenuBody = /*#__PURE__*/_react.default.createElement(_FloatingMenu.default, {
        focusTrap: focusTrap,
        triggerRef: this._triggerRef,
        menuDirection: direction,
        menuOffset: flipped ? menuOffsetFlip : menuOffset,
        menuRef: this._bindMenuBody,
        flipped: this.props.flipped,
        target: this._getTarget,
        onPlace: this._handlePlace,
        selectorPrimaryFocus: this.props.selectorPrimaryFocus
      }, /*#__PURE__*/_react.default.cloneElement(menuBody, {
        'data-floating-menu-direction': direction
      }));

      var iconProps = {
        className: overflowMenuIconClasses,
        'aria-label': iconDescription
      };
      return /*#__PURE__*/_react.default.createElement(_ClickListener.default, {
        onClickOutside: this.handleClickOutside
      }, /*#__PURE__*/_react.default.createElement("button", (0, _extends2.default)({}, other, {
        type: "button",
        "aria-haspopup": true,
        "aria-expanded": this.state.open,
        className: overflowMenuClasses,
        onKeyDown: this.handleKeyPress,
        onClick: this.handleClick,
        "aria-label": ariaLabel,
        id: id,
        ref: (0, _mergeRefs.default)(this._triggerRef, ref),
        "aria-controls": this.state.open ? menuBodyId : null
      }), /*#__PURE__*/_react.default.createElement(IconElement, iconProps, iconDescription && /*#__PURE__*/_react.default.createElement("title", null, iconDescription)), open && wrappedMenuBody));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(_ref2, state) {
      var open = _ref2.open;
      var prevOpen = state.prevOpen;
      return prevOpen === open ? null : {
        open: open,
        prevOpen: open
      };
    }
  }]);
  return OverflowMenu;
}(_react.Component);

exports.OverflowMenu = OverflowMenu;
(0, _defineProperty2.default)(OverflowMenu, "propTypes", {
  /**
   * The ARIA label.
   */
  ariaLabel: FeatureFlags.enabled('enable-v11-release') ? _propTypes.default.string.isRequired : _propTypes.default.string,

  /**
   * The child nodes.
   */
  children: _propTypes.default.node,

  /**
   * The CSS class names.
   */
  className: _propTypes.default.string,

  /**
   * The menu direction.
   */
  direction: _propTypes.default.oneOf([_FloatingMenu.DIRECTION_TOP, _FloatingMenu.DIRECTION_BOTTOM]),

  /**
   * `true` if the menu alignment should be flipped.
   */
  flipped: _propTypes.default.bool,

  /**
   * Enable or disable focus trap behavior
   */
  focusTrap: _propTypes.default.bool,

  /**
   * The CSS class for the icon.
   */
  iconClass: _propTypes.default.string,

  /**
   * The icon description.
   */
  iconDescription: _propTypes.default.string.isRequired,

  /**
   * The element ID.
   */
  id: _propTypes.default.string,

  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make OverflowMenu background color same as container background color.
   */
  light: FeatureFlags.enabled('enable-v11-release') ? (0, _deprecate.default)(_propTypes.default.bool, 'The `light` prop for `OverflowMenu` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead.') : _propTypes.default.bool,

  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffset: _propTypes.default.oneOfType([_propTypes.default.shape({
    top: _propTypes.default.number,
    left: _propTypes.default.number
  }), _propTypes.default.func]),

  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffsetFlip: _propTypes.default.oneOfType([_propTypes.default.shape({
    top: _propTypes.default.number,
    left: _propTypes.default.number
  }), _propTypes.default.func]),

  /**
   * The class to apply to the menu options
   */
  menuOptionsClass: _propTypes.default.string,

  /**
   * The event handler for the `click` event.
   */
  onClick: _propTypes.default.func,

  /**
   * Function called when menu is closed
   */
  onClose: _propTypes.default.func,

  /**
   * The event handler for the `focus` event.
   */
  onFocus: _propTypes.default.func,

  /**
   * The event handler for the `keydown` event.
   */
  onKeyDown: _propTypes.default.func,

  /**
   * Function called when menu is opened
   */
  onOpen: _propTypes.default.func,

  /**
   * `true` if the menu should be open.
   */
  open: _propTypes.default.bool,

  /**
   * Function called to override icon rendering.
   */
  renderIcon: _propTypes.default.oneOfType([_propTypes.default.func, _propTypes.default.object]),

  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the OverflowMenu opens
   */
  selectorPrimaryFocus: _propTypes.default.string,

  /**
   * Specify the size of the OverflowMenu. Currently supports either `sm`, 'md' (default) or 'lg` as an option.
   */
  size: FeatureFlags.enabled('enable-v11-release') ? _propTypes.default.oneOf(['sm', 'md', 'lg']) : _propTypes.default.oneOf(['sm', 'md', 'lg', 'xl'])
});
(0, _defineProperty2.default)(OverflowMenu, "contextType", _usePrefix.PrefixContext);
(0, _defineProperty2.default)(OverflowMenu, "defaultProps", {
  ariaLabel: FeatureFlags.enabled('enable-v11-release') ? null : 'Open and close list of options',
  iconDescription: 'Open and close list of options',
  open: false,
  direction: _FloatingMenu.DIRECTION_BOTTOM,
  flipped: false,
  focusTrap: true,
  renderIcon: _iconsReact.OverflowMenuVertical16,
  onClick: function onClick() {},
  onKeyDown: function onKeyDown() {},
  onClose: function onClose() {},
  onOpen: function onOpen() {},
  menuOffset: getMenuOffset,
  menuOffsetFlip: getMenuOffset,
  light: false,
  selectorPrimaryFocus: '[data-overflow-menu-primary-focus]'
});

var _default = function () {
  var forwardRef = function forwardRef(props, ref) {
    return /*#__PURE__*/_react.default.createElement(OverflowMenu, (0, _extends2.default)({}, props, {
      innerRef: ref
    }));
  };

  forwardRef.displayName = 'OverflowMenu';
  return /*#__PURE__*/_react.default.forwardRef(forwardRef);
}();

exports.default = _default;