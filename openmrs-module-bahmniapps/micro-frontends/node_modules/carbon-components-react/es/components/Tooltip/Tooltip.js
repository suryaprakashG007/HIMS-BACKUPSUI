import _extends from "@babel/runtime/helpers/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import _classCallCheck from "@babel/runtime/helpers/classCallCheck";
import _createClass from "@babel/runtime/helpers/createClass";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _inherits from "@babel/runtime/helpers/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
var _excluded = ["triggerId", "tooltipBodyId", "children", "className", "triggerClassName", "focusTrap", "triggerText", "showIcon", "iconName", "iconDescription", "renderIcon", "menuOffset", "tabIndex", "innerRef", "selectorPrimaryFocus", "tooltipId", "autoOrientation", "align"];

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

/**
 * Copyright IBM Corp. 2016, 2018
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import { isForwardRef } from 'react-is';
import debounce from 'lodash.debounce';
import classNames from 'classnames';
import { Information16 as Information } from '@carbon/icons-react';
import FloatingMenu, { DIRECTION_LEFT, DIRECTION_TOP, DIRECTION_RIGHT, DIRECTION_BOTTOM } from '../../internal/FloatingMenu';
import ClickListener from '../../internal/ClickListener';
import mergeRefs from '../../tools/mergeRefs';
import { keys, matches as keyDownMatch } from '../../internal/keyboard';
import isRequiredOneOf from '../../prop-types/isRequiredOneOf';
import requiredIfValueExists from '../../prop-types/requiredIfValueExists';
import { useControlledStateWithValue } from '../../internal/FeatureFlags';
import { PrefixContext } from '../../internal/usePrefix';
/**
 * @param {Element} menuBody The menu body with the menu arrow.
 * @param {string} menuDirection Where the floating menu menu should be placed relative to the trigger button.
 * @returns {FloatingMenu~offset} The adjustment of the floating menu position, upon the position of the menu arrow.
 * @private
 */

var getMenuOffset = function getMenuOffset(menuBody, menuDirection) {
  var _DIRECTION_LEFT$DIREC, _DIRECTION_LEFT$DIREC2;

  var arrowStyle = menuBody.ownerDocument.defaultView.getComputedStyle(menuBody, ':before');
  var arrowPositionProp = (_DIRECTION_LEFT$DIREC = {}, _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_LEFT, 'right'), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_TOP, 'bottom'), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_RIGHT, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC, DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC)[menuDirection];
  var menuPositionAdjustmentProp = (_DIRECTION_LEFT$DIREC2 = {}, _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_LEFT, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_TOP, 'top'), _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_RIGHT, 'left'), _defineProperty(_DIRECTION_LEFT$DIREC2, DIRECTION_BOTTOM, 'top'), _DIRECTION_LEFT$DIREC2)[menuDirection];
  var values = [arrowPositionProp, 'border-bottom-width'].reduce(function (o, name) {
    return _objectSpread(_objectSpread({}, o), {}, _defineProperty({}, name, Number((/^([\d-]+)px$/.exec(arrowStyle.getPropertyValue(name)) || [])[1])));
  }, {});
  values[arrowPositionProp] = values[arrowPositionProp] || -6; // IE, etc.

  if (Object.keys(values).every(function (name) {
    return !isNaN(values[name]);
  })) {
    var arrowPosition = values[arrowPositionProp],
        borderBottomWidth = values['border-bottom-width'];
    return _defineProperty({
      left: 0,
      top: 0
    }, menuPositionAdjustmentProp, Math.sqrt(Math.pow(borderBottomWidth, 2) * 2) - arrowPosition);
  }
};

var Tooltip = /*#__PURE__*/function (_Component) {
  _inherits(Tooltip, _Component);

  var _super = _createSuper(Tooltip);

  function Tooltip(props) {
    var _this;

    _classCallCheck(this, Tooltip);

    _this = _super.call(this, props);

    _defineProperty(_assertThisInitialized(_this), "_tooltipEl", null);

    _defineProperty(_assertThisInitialized(_this), "_triggerRef", /*#__PURE__*/React.createRef());

    _defineProperty(_assertThisInitialized(_this), "_tooltipId", _this.props.id || _this.props.tooltipId || "__carbon-tooltip_".concat(Math.random().toString(36).substr(2)));

    _defineProperty(_assertThisInitialized(_this), "_tooltipDismissed", false);

    _defineProperty(_assertThisInitialized(_this), "updateOrientation", function (params) {
      if (_this.props.autoOrientation) {
        var newOrientation = _this.getBestDirection(params);

        var direction = newOrientation.direction,
            align = newOrientation.align;

        if (direction !== _this.state.storedDirection) {
          _this.setState({
            open: false
          }, function () {
            _this.setState({
              open: true,
              storedDirection: direction
            });
          });
        }

        if (align === 'original') {
          _this.setState({
            storedAlign: _this.props.align
          });
        } else {
          _this.setState({
            storedAlign: align
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "getBestDirection", function (_ref2) {
      var menuSize = _ref2.menuSize,
          _ref2$refPosition = _ref2.refPosition,
          refPosition = _ref2$refPosition === void 0 ? {} : _ref2$refPosition,
          _ref2$offset = _ref2.offset,
          offset = _ref2$offset === void 0 ? {} : _ref2$offset,
          _ref2$direction = _ref2.direction,
          direction = _ref2$direction === void 0 ? DIRECTION_BOTTOM : _ref2$direction,
          _ref2$scrollX = _ref2.scrollX,
          pageXOffset = _ref2$scrollX === void 0 ? 0 : _ref2$scrollX,
          _ref2$scrollY = _ref2.scrollY,
          pageYOffset = _ref2$scrollY === void 0 ? 0 : _ref2$scrollY,
          container = _ref2.container;
      var _refPosition$left = refPosition.left,
          refLeft = _refPosition$left === void 0 ? 0 : _refPosition$left,
          _refPosition$top = refPosition.top,
          refTop = _refPosition$top === void 0 ? 0 : _refPosition$top,
          _refPosition$right = refPosition.right,
          refRight = _refPosition$right === void 0 ? 0 : _refPosition$right,
          _refPosition$bottom = refPosition.bottom,
          refBottom = _refPosition$bottom === void 0 ? 0 : _refPosition$bottom;
      var scrollX = container.position !== 'static' ? 0 : pageXOffset;
      var scrollY = container.position !== 'static' ? 0 : pageYOffset;
      var relativeDiff = {
        top: container.position !== 'static' ? container.rect.top : 0,
        left: container.position !== 'static' ? container.rect.left : 0
      };
      var width = menuSize.width,
          height = menuSize.height;
      var _offset$top = offset.top,
          top = _offset$top === void 0 ? 0 : _offset$top,
          _offset$left = offset.left,
          left = _offset$left === void 0 ? 0 : _offset$left;
      var refCenterHorizontal = (refLeft + refRight) / 2;
      var refCenterVertical = (refTop + refBottom) / 2; // Calculate whether a new direction is needed to stay in parent.
      // It will switch the current direction to the opposite i.e.
      // If the direction="top" and the top boundary is overflowed
      // then it switches the direction to "bottom".

      var newDirection = function newDirection() {
        switch (direction) {
          case DIRECTION_LEFT:
            return refLeft - width + scrollX - left - relativeDiff.left < 0 ? DIRECTION_RIGHT : direction;

          case DIRECTION_TOP:
            return refTop - height + scrollY - top - relativeDiff.top < 0 ? DIRECTION_BOTTOM : direction;

          case DIRECTION_RIGHT:
            return refRight + scrollX + left - relativeDiff.left + width > container.rect.width ? DIRECTION_LEFT : direction;

          case DIRECTION_BOTTOM:
            return refBottom + scrollY + top - relativeDiff.top + height > container.rect.height ? DIRECTION_TOP : direction;

          default:
            // If there is a new direction then ignore the logic above
            return direction;
        }
      }; // Calculate whether a new alignment is needed to stay in parent
      // If the direction is left or right this involves checking the
      // overflow in the vertical direction. If the direction is top or
      // bottom, this involves checking overflow in the horizontal direction.
      // "original" is used to signify no change.


      var newAlignment = function newAlignment() {
        switch (direction) {
          case DIRECTION_LEFT:
          case DIRECTION_RIGHT:
            if (refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top < 0) {
              // If goes above the top boundary
              return 'start';
            } else if (refCenterVertical - height / 2 + scrollY + top - 9 - relativeDiff.top + height > container.rect.height) {
              // If goes below the bottom boundary
              return 'end';
            } else {
              // No need to change alignment
              return 'original';
            }

          case DIRECTION_TOP:
          case DIRECTION_BOTTOM:
            if (refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left < 0) {
              // If goes below the left boundary
              return 'start';
            } else if (refCenterHorizontal - width / 2 + scrollX + left - relativeDiff.left + width > container.rect.width) {
              // If it goes over the right boundary
              return 'end';
            } else {
              // No need to change alignment
              return 'original';
            }

          default:
            // No need to change alignment
            return 'original';
        }
      };

      return {
        direction: newDirection(),
        align: newAlignment()
      };
    });

    _defineProperty(_assertThisInitialized(_this), "_handleUserInputOpenClose", function (event, _ref3) {
      var open = _ref3.open;

      if (_this.isControlled && _this.props.onChange) {
        // Callback to the parent to let them decide what to do
        _this.props.onChange(event, {
          open: open
        });

        return;
      } // capture tooltip body element before it is removed from the DOM


      var tooltipBody = _this._tooltipEl;

      _this.setState({
        open: open
      }, function () {
        if (_this.props.onChange) {
          _this.props.onChange(event, {
            open: open
          });
        }

        if (!open && tooltipBody && tooltipBody.id === _this._tooltipId) {
          _this._tooltipDismissed = true;
          var currentActiveNode = event === null || event === void 0 ? void 0 : event.relatedTarget;

          if (!currentActiveNode && document.activeElement === document.body && (event === null || event === void 0 ? void 0 : event.type) !== 'click') {
            var _this$_triggerRef;

            (_this$_triggerRef = _this._triggerRef) === null || _this$_triggerRef === void 0 ? void 0 : _this$_triggerRef.current.focus();
          }
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_handleFocus", function (state, evt) {
      var currentTarget = evt.currentTarget,
          relatedTarget = evt.relatedTarget;

      if (currentTarget !== relatedTarget) {
        _this._tooltipDismissed = false;
      }

      if (state === 'over' && !_this.isControlled) {
        if (!_this._tooltipDismissed) {
          _this._handleUserInputOpenClose(evt, {
            open: true
          });
        }

        _this._tooltipDismissed = false;
      } else if (state !== 'out') {
        // Note: SVGElement in IE11 does not have `.contains()`
        var triggerEl = _this._triggerRef.current;

        var shouldPreventClose = relatedTarget && (triggerEl && (triggerEl === null || triggerEl === void 0 ? void 0 : triggerEl.contains(relatedTarget)) || _this._tooltipEl && _this._tooltipEl.contains(relatedTarget));

        if (!shouldPreventClose) {
          _this._handleUserInputOpenClose(evt, {
            open: false
          });
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "_debouncedHandleFocus", null);

    _defineProperty(_assertThisInitialized(_this), "_getTarget", function () {
      var triggerEl = _this._triggerRef.current;
      return triggerEl && triggerEl.closest('[data-floating-menu-container]') || document.body;
    });

    _defineProperty(_assertThisInitialized(_this), "handleMouse", function (evt) {
      evt.persist();
      var state = {
        focus: 'over',
        blur: 'out',
        click: 'click'
      }[evt.type];
      var hadContextMenu = _this._hasContextMenu;

      if (evt.type === 'click' || evt.type === 'contextmenu') {
        _this._hasContextMenu = evt.type === 'contextmenu';
      }

      if (_this._hasContextMenu) {
        _this._handleUserInputOpenClose(evt, {
          open: false
        });

        return;
      }

      if (state === 'click') {
        evt.preventDefault();
        var shouldOpen = _this.isControlled ? !_this.props.open : !_this.state.open;

        _this._handleUserInputOpenClose(evt, {
          open: shouldOpen
        });
      } else if (state && (state !== 'out' || !hadContextMenu)) {
        var _assertThisInitialize;

        (_assertThisInitialize = _assertThisInitialized(_this)) === null || _assertThisInitialize === void 0 ? void 0 : _assertThisInitialize._debouncedHandleFocus(state, evt);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleClickOutside", function (evt) {
      var shouldPreventClose = evt && evt.target && _this._tooltipEl && _this._tooltipEl.contains(evt.target);

      if (!shouldPreventClose && _this.state.open) {
        _this._handleUserInputOpenClose(evt, {
          open: false
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleKeyPress", function (event) {
      if (keyDownMatch(event, [keys.Escape, keys.Tab])) {
        event.stopPropagation();

        _this._handleUserInputOpenClose(event, {
          open: false
        });
      }

      if (keyDownMatch(event, [keys.Enter, keys.Space])) {
        event.stopPropagation();
        event.preventDefault();
        var shouldOpen = _this.isControlled ? !_this.props.open : !_this.state.open;

        _this._handleUserInputOpenClose(event, {
          open: shouldOpen
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "handleEscKeyPress", function (event) {
      var _ref4 = _this.isControlled ? _this.props : _this.state,
          open = _ref4.open;

      if (open && keyDownMatch(event, [keys.Escape])) {
        event.stopPropagation();
        return _this._handleUserInputOpenClose(event, {
          open: false
        });
      }
    });

    _this.isControlled = props.open !== undefined;

    if (useControlledStateWithValue && _this.isControlled) {
      // Skips the logic of setting initial state if this component is controlled
      return _possibleConstructorReturn(_this);
    }

    var _open = useControlledStateWithValue ? props.defaultOpen : props.open;

    _this.state = {
      open: _open,
      storedDirection: props.direction,
      storedAlign: props.align
    };
    return _this;
  }

  _createClass(Tooltip, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this._debouncedHandleFocus) {
        this._debouncedHandleFocus = debounce(this._handleFocus, 200);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (prevProps.direction != this.props.direction) {
        this.setState({
          storedDirection: this.props.direction
        });
      }

      if (prevProps.align != this.props.align) {
        this.setState({
          storedAlign: this.props.align
        });
      }

      if (prevState.open && !this.state.open) {
        // Reset orientation when closing
        this.setState({
          storedDirection: this.props.direction,
          storedAlign: this.props.align
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this._debouncedHandleFocus) {
        this._debouncedHandleFocus.cancel();

        this._debouncedHandleFocus = null;
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props = this.props,
          _this$props$triggerId = _this$props.triggerId,
          triggerId = _this$props$triggerId === void 0 ? this.triggerId = this.triggerId || "__carbon-tooltip-trigger_".concat(Math.random().toString(36).substr(2)) : _this$props$triggerId,
          tooltipBodyId = _this$props.tooltipBodyId,
          children = _this$props.children,
          className = _this$props.className,
          triggerClassName = _this$props.triggerClassName,
          focusTrap = _this$props.focusTrap,
          triggerText = _this$props.triggerText,
          showIcon = _this$props.showIcon,
          iconName = _this$props.iconName,
          iconDescription = _this$props.iconDescription,
          IconCustomElement = _this$props.renderIcon,
          menuOffset = _this$props.menuOffset,
          _this$props$tabIndex = _this$props.tabIndex,
          tabIndex = _this$props$tabIndex === void 0 ? 0 : _this$props$tabIndex,
          ref = _this$props.innerRef,
          selectorPrimaryFocus = _this$props.selectorPrimaryFocus,
          tooltipId = _this$props.tooltipId,
          autoOrientation = _this$props.autoOrientation,
          align = _this$props.align,
          other = _objectWithoutProperties(_this$props, _excluded);

      var _ref5 = this.isControlled ? this.props : this.state,
          open = _ref5.open;

      var _this$state = this.state,
          storedDirection = _this$state.storedDirection,
          storedAlign = _this$state.storedAlign;
      return /*#__PURE__*/React.createElement(PrefixContext.Consumer, null, function (prefix) {
        var _classNames;

        var tooltipClasses = classNames("".concat(prefix, "--tooltip"), (_classNames = {}, _defineProperty(_classNames, "".concat(prefix, "--tooltip--shown"), open), _defineProperty(_classNames, "".concat(prefix, "--tooltip--").concat(storedDirection), storedDirection), _defineProperty(_classNames, "".concat(prefix, "--tooltip--align-").concat(storedAlign), storedAlign), _classNames), className);
        var triggerClasses = classNames("".concat(prefix, "--tooltip__label"), triggerClassName);
        var refProp = mergeRefs(_this2._triggerRef, ref);
        var iconProperties = {
          name: iconName,
          role: null,
          description: null
        };

        var properties = _objectSpread({
          role: 'button',
          tabIndex: tabIndex,
          onClick: _this2.handleMouse,
          onContextMenu: _this2.handleMouse,
          onKeyDown: _this2.handleKeyPress,
          onMouseOver: _this2.handleMouse,
          onMouseOut: _this2.handleMouse,
          onFocus: _this2.handleMouse,
          onBlur: _this2.handleMouse,
          'aria-controls': !open ? undefined : _this2._tooltipId,
          'aria-expanded': open,
          'aria-describedby': open ? _this2._tooltipId : null
        }, triggerText ? {
          'aria-labelledby': triggerId
        } : {
          'aria-label': iconDescription
        });

        return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(ClickListener, {
          onClickOutside: _this2.handleClickOutside
        }, showIcon ? /*#__PURE__*/React.createElement("div", {
          id: triggerId,
          className: triggerClasses
        }, triggerText, /*#__PURE__*/React.createElement("div", _extends({
          className: "".concat(prefix, "--tooltip__trigger")
        }, properties, {
          ref: refProp,
          "aria-describedby": tooltipBodyId || properties['aria-describedby']
        }), /*#__PURE__*/React.createElement(IconCustomElement, iconProperties))) : /*#__PURE__*/React.createElement("div", _extends({
          id: triggerId,
          className: triggerClasses,
          ref: refProp
        }, properties, {
          "aria-describedby": tooltipBodyId || properties['aria-describedby']
        }), triggerText)), open && /*#__PURE__*/React.createElement(FloatingMenu, {
          focusTrap: focusTrap,
          selectorPrimaryFocus: _this2.props.selectorPrimaryFocus,
          target: _this2._getTarget,
          triggerRef: _this2._triggerRef,
          menuDirection: storedDirection,
          menuOffset: menuOffset,
          menuRef: function menuRef(node) {
            _this2._tooltipEl = node;
          },
          updateOrientation: _this2.updateOrientation
        }, /*#__PURE__*/React.createElement("div", _extends({
          className: tooltipClasses,
          onKeyDown: _this2.handleEscKeyPress
        }, other, {
          id: _this2._tooltipId,
          "data-floating-menu-direction": storedDirection,
          onMouseOver: _this2.handleMouse,
          onMouseOut: _this2.handleMouse,
          onFocus: _this2.handleMouse,
          onBlur: _this2.handleMouse,
          onContextMenu: _this2.handleMouse
        }), /*#__PURE__*/React.createElement("span", {
          className: "".concat(prefix, "--tooltip__caret")
        }), /*#__PURE__*/React.createElement("div", {
          className: "".concat(prefix, "--tooltip__content"),
          "aria-labelledby": _this2._tooltipId,
          role: "dialog"
        }, children))));
      });
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(_ref6, state) {
      var open = _ref6.open;

      /**
       * so that tooltip can be controlled programmatically through this `open` prop
       */
      var prevOpen = state.prevOpen;
      return prevOpen === open ? null : {
        open: open,
        prevOpen: open
      };
    }
  }]);

  return Tooltip;
}(Component);

_defineProperty(Tooltip, "propTypes", _objectSpread({
  /**
   * Specify the alignment (to the trigger button) of the tooltip.
   * Can be one of: start, center, or end.
   */
  align: PropTypes.oneOf(['start', 'center', 'end']),

  /**
   * Whether or not to re-orientate the tooltip if it goes outside,
   * of the bounds of the parent.
   */
  autoOrientation: PropTypes.bool,

  /**
   * Contents to put into the tooltip.
   */
  children: PropTypes.node,

  /**
   * The CSS class names of the tooltip.
   */
  className: PropTypes.string,

  /**
   * Optional starting value for uncontrolled state
   */
  defaultOpen: PropTypes.bool,

  /**
   * Where to put the tooltip, relative to the trigger UI.
   */
  direction: PropTypes.oneOf(['bottom', 'top', 'left', 'right']),

  /**
   * Enable or disable focus trap behavior
   */
  focusTrap: PropTypes.bool,

  /**
   * The name of the default tooltip icon.
   */
  iconName: PropTypes.string,

  /**
   * The adjustment of the tooltip position.
   */
  menuOffset: PropTypes.oneOfType([PropTypes.shape({
    top: PropTypes.number,
    left: PropTypes.number
  }), PropTypes.func]),

  /**
   * * the signature of the event handler will be:
   * * `onChange(event, { open })` where:
   *   * `event` is the (React) raw event
   *   * `open` is the new value
   */
  onChange: !useControlledStateWithValue ? PropTypes.func : requiredIfValueExists(PropTypes.func),

  /**
   * Open/closed state.
   */
  open: PropTypes.bool,

  /**
   * The callback function to optionally render the icon element.
   * It should be a component with React.forwardRef().
   */
  renderIcon: function renderIcon(props, propName, componentName) {
    if (props[propName] == undefined) {
      return;
    }

    var RefForwardingComponent = props[propName];

    if (!isForwardRef( /*#__PURE__*/React.createElement(RefForwardingComponent, null))) {
      return new Error("Invalid value of prop '".concat(propName, "' supplied to '").concat(componentName, "',\n                          it should be created/wrapped with React.forwardRef() to have a ref and access the proper\n                          DOM node of the element to calculate its position in the viewport."));
    }
  },

  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the Tooltip opens
   */
  selectorPrimaryFocus: PropTypes.string,

  /**
   * `true` to show the default tooltip icon.
   */
  showIcon: PropTypes.bool,

  /**
   * Optional prop to specify the tabIndex of the Tooltip
   */
  tabIndex: PropTypes.number,

  /**
   * The ID of the tooltip body content.
   */
  tooltipBodyId: PropTypes.string,

  /**
   * The ID of the tooltip content.
   */
  tooltipId: PropTypes.string,

  /**
   * The CSS class names of the trigger UI.
   */
  triggerClassName: PropTypes.string,

  /**
   * The ID of the trigger button.
   */
  triggerId: PropTypes.string
}, isRequiredOneOf({
  /**
   * The content to put into the trigger UI, except the (default) tooltip icon.
   */
  triggerText: PropTypes.node,

  /**
   * The description of the default tooltip icon, to be put in its SVG 'aria-label' and 'alt' .
   */
  iconDescription: PropTypes.string
})));

_defineProperty(Tooltip, "defaultProps", {
  align: 'center',
  direction: DIRECTION_BOTTOM,
  focusTrap: true,
  renderIcon: Information,
  showIcon: true,
  triggerText: null,
  menuOffset: getMenuOffset,
  selectorPrimaryFocus: '[data-tooltip-primary-focus]'
});

export { Tooltip };
export default (function () {
  var forwardRef = function forwardRef(props, ref) {
    return /*#__PURE__*/React.createElement(Tooltip, _extends({}, props, {
      innerRef: ref
    }));
  };

  forwardRef.displayName = 'Tooltip';
  return /*#__PURE__*/React.forwardRef(forwardRef);
})();